# -*- coding: utf-8 -*-
"""Teoria Computacion S2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10p5dvQLQ2-GO04JwAhz3z87pfKGok7Yb

Lenguaje es un cojunto de palabra.

**Ejemplo de Alfabeto**

A* es una cerradura

A es un alfabeto
"""

A = {'1','2','3'}

print(A)

A_asterisco = {'','1','2','3','12','13','23','21'}

a = '121'

a in A_asterisco

"""**EXPRESIONES REGULARES**


**re_str1**
Tiene que ir de manera secuencial

**re_str2**
Es mas especifica del patron

**re_str3**
Es mas 'global' solo brinda un rango de busqueda
"""

import re

re_str1= '1*2*3*'

re_str2= "[1|2|3|5|7]*"

re_str3= "[1-7]*"

prog = re.compile(re_str1)
result = prog.match('6312322212312312332212321222212111')
print(result)

prog = re.compile(re_str2)
result = prog.match('6312322212312312332212321222212111')
print(result)

prog = re.compile(re_str3)
result = prog.match('6312322212312312332212321222212111')
print(result)

"""**EJERCICIOS CONCATENACION**

(A* )* = A*

A.A*= A+

(A+ )* = A*

A* . A * = A* 


https://sites.google.com/site/matediscretashernandezgomez/1-1-definicion-de-conjun/13-conjunto-vacio

**EJERCICIO CONCATENACION**

A.B

A = {00,11}
B = {∑}

A.B = {00 ∑, 11 ∑}

A.B = {ab | a e A & b e B}

**Ejercicio de Cerradura**

Puede concatenar la primer cadena con otra cadena de A (con la misma cadena o con otras cadenas). Tambien puede empezar con otro cualquier elemento. y se puede concatenar con ella misma las veces que quiera.

(A* ) *
"""

A = {'00','01'}

A_asterisco = {'', '0000','00000000','00010001010001','01','010000010001',...}

a = '00000000'
print(A)
a in A_asterisco

"""### **AUTOMATAS**

M = (Q,∑,S,F,S)

∑ = Alfabero

s = Estado Inicial

Q = Coleccion finita de estado

F = Coleccion de estados finales o de aceptacion

S = Qx∑ -> Q determina el siguiente estado para (q:, o)

**Ejercicio Automata 1**
"""

import networkx as nx

G = nx.MultiDiGraph()
G.add_node("Q0")
G.add_node("Q1")

G.add_edge("Q0","Q0",weight=1)
G.add_edge("Q0","Q1",weight=7)
G.add_edge("Q1","Q1",weight=5)
G.add_edge("Q1","Q0",weight=2)

print("Nodes of graph: ")
print(G.nodes())
print("Edges of graph: ")
print(G.edges())

print("Weight:")
print("Q0-Q0" ,
      G.get_edge_data("Q0","Q0"))
print("Q0-Q1" ,
    G.get_edge_data("Q0","Q1"))
print("Q1-Q0" ,
    G.get_edge_data("Q1","Q0"))
print("Q1-Q0" ,
    G.get_edge_data("Q1","Q0"))

nx.draw(G, with_labels=True)

"""**Ejercicio Automata 2**"""

import networkx as nx

G = nx.MultiDiGraph()
G.add_node("Q0")
G.add_node("Q1")
G.add_node("Q2")
G.add_node("Q3")

G.add_edge("Q0","Q0",weight=1)
G.add_edge("Q0","Q1",weight=7)
G.add_edge("Q1","Q0",weight=2)
G.add_edge("Q1","Q2",weight=2)
G.add_edge("Q2","Q0",weight=3)
G.add_edge("Q2","Q3",weight=3)
G.add_edge("Q3","Q3",weight=8)

print("Nodes of graph: ")
print(G.nodes())
print("Edges of graph: ")
print(G.edges())

print("Weight:")
print("Q0-Q0" ,
      G.get_edge_data("Q0","Q0"))
print("Q0-Q1" ,
    G.get_edge_data("Q0","Q1"))
print("Q1-Q0" ,
    G.get_edge_data("Q1","Q0"))
print("Q1-Q2" ,
    G.get_edge_data("Q1","Q2"))
print("Q2-Q0" ,
    G.get_edge_data("Q2","Q0"))
print("Q2-Q3" ,
    G.get_edge_data("Q2","Q3"))
print("Q3-Q3" ,
    G.get_edge_data("Q3","Q3"))
nx.draw(G, with_labels=True)

"""**Ejercicio Automata 3**"""

import networkx as nx

G = nx.MultiDiGraph()
G.add_node("Q0")
G.add_node("Q1")
G.add_node("Q2")
G.add_edge("Q0","Q1",weight=5)
G.add_edge("Q1","Q2",weight=2)
G.add_edge("Q0","Q0",weight=1)
G.add_edge("Q1","Q1",weight=3)
G.add_edge("Q2","Q2",weight=7)

print("Nodes of graph: ")
print(G.nodes())
print("Edges of graph: ")
print(G.edges())

print("Weight:")
print("Q0-Q1" ,
      G.get_edge_data("Q0","Q1"))
print("Q1-Q2" ,
    G.get_edge_data("Q1","Q2"))
print("Q0-Q0" ,
    G.get_edge_data("Q0","Q0"))
print("Q1-Q1" ,
    G.get_edge_data("Q1","Q1"))
print("Q2-Q2" ,
    G.get_edge_data("Q2","Q2"))
nx.draw(G, with_labels=True)